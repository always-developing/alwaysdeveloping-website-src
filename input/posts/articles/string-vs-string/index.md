---
title: "C# String vs string"
lead: "Which to use? Does it matter?"
Published: 10/21/2021
slug: "string-vs-string"
draft: false
toc: true
categories:
    - Blog
tags:
    - c#
    - .net
    - vs
    - syntax
---

## What's the issue?

When working with strings in C# one can either use `String` (uppercase) or `string` (lowercase) and in both cases the code will compile and execute.

Explicitly typed string variables can be done in either of the following ways:

``` csharp
string variable = "Always Developing";
String variable = "Always Developing";
```

Or when invoking string related methods, both of the following examples are valid:

``` csharp
string variable = string.Format("Always Developing using {0}", "C#");
String variable = String.Format("Always Developing using {0}", "Typescript");
```

Whats the difference between using `String` and using `string`? Is there a difference? Does it really matter?

## Is there a difference?

- `System.String` is a .NET CLR (Common Runtime Library) class. This means it's part of the core .NET environment, which sits one level below the specific language implementation.

- `string` is a C# specific keyword, which is an alias for the CLR `System.String` type.

What this means is that `string` is just another name for `System.String` and they are **effectively equivalent**. 

<?# InfoBlock ?>
The same way `int` is an alias and maps to the CLR type `System.Int32` and `long` is an alias and map to CLR type `System.Int64`, `string` is an alias and maps to the CLR type `System.String`
<?#/ InfoBlock ?>

## Deeper comparisons
### Variable declaration


We can further confirm `String` and `string` are equivalent by comparing the IL (Intermediate Language) code generated when declaring variables using both of the types.

<?# InfoBlock ?>
This post is primarily to compare the C# `String` and `string` types, but VB.NET examples have also been included in the comparison for completeness.
<?#/ InfoBlock ?>

Take these three methods, all functionally equivalent, but declaring the variable using the different types:

``` csharp
public string GetString()
{
    String variable = "string value";
    return variable;
}
```

``` csharp
public string GetString()
{
    string variable = "string value";
    return variable;
}
```

``` csharp
Public Function GetString() As String
    Dim variable As String = "string value"
    Return variable
End Function
```

The IL code generated by all three examples is all effectively identical:

``` csharp
// Methods
.method public hidebysig 
    instance string GetString () cil managed 
{
    // Method begins at RVA 0x2050
    // Code size 6 (0x6)
    .maxstack 8

    IL_0000: ldstr "string value"
    IL_0005: ret
} // end of method CClass::GetString
```

### String method invocation

So it's confirmed that `String` and `string` are equivalent when declaring variables, but what about with method invocation?

Again, three functionally equivalent methods, but invoking the `Format` method differently:

``` csharp
public string StringFormat()
{
    var insertString = "C#";
    var variable = String.Format("Always Developing using {0}", insertString);
    return variable;
}
```

``` csharp
public string StringFormat()
{
    var insertString = "C#";
    var variable = string.Format("Always Developing using {0}", insertString);
    return variable;
}
```

``` csharp
Public Function StringFormat() As String
    Dim insertString = "C#"
    Dim variable = String.Format("Always Developing using {0}", insertString)
    Return variable
End Function
```

When the generated IL code is compared, in all three cases, it is equivalent:

``` csharp
// Methods
.method public hidebysig 
    instance string StringFormat () cil managed 
{
    // Method begins at RVA 0x2050
    // Code size 18 (0x12)
    .maxstack 2
    .locals init (
        [0] string insertString
    )

    IL_0000: ldstr "C#"
    IL_0005: stloc.0
    IL_0006: ldstr "Always Developing using {0}"
    IL_000b: ldloc.0
    IL_000c: call string [System.Private.CoreLib]System.String::Format(string, object)
    IL_0011: ret
} // end of method CClass::StringFormat
```

## Conclusion

Use either `String` or `string`, they are effectively equivalent.  

However, the recommended approach is to use the C# language specific keyword `string`, as it works without having to include `using System;` 

<?# InfoBlock ?>
The recommendation method of using `string` comes from the official _**[Microsoft documentation](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/)**_, and is included as a default style rule in _**[Visual Studio](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/ide0049)**_
<?#/ InfoBlock ?>

<?# TickBlock ?>
It is recommended to use implicitly type local variables (where appropriate) by using the `var` keyword (instead of `string`, in the above examples), and having the type inferred by the compiled.  

The use of `var` versus explicate declaration is a **personal preference**, and will not effect the execution or performance of the code.  

Personally I use `var` in my code: I find the code cleaner and easier to read. One can see the type being inferred by the compiler by hovering the mouse cursor over the `var` keyword in Visual Studio.
<?#/ TickBlock ?>


## References and links
[Microsoft string guidance](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/)  
[Microsoft style rule](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/ide0049)  
[Implicitly typed variables](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions#implicitly-typed-local-variables)  
[Sharp lab - IL generator](https://sharplab.io)