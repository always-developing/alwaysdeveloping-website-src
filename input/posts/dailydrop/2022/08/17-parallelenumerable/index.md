---
title: "Parallel processing with ParallelEnumerable "
lead: "Built in Linq parallel processing with ParallelEnumerable"
Published: "08/17/2022 01:00:00+0200"
slug: "17-parallelenumerable"
draft: false
toc: true
categories:
    - DailyDrop
tags:
   - c#
   - .net
   - enumerable
   - parallel

---

## Daily Knowledge Drop

Linq has built in parallel functionality, available in the `ParallelEnumerable` class.  This functionality is available as _extension methods_ on `ParallelQuery`, which is generated by calling `AsParallel` on an _IEnumerable_.

---

## Usage

The usage of the functionality offered by `ParallelEnumerable` is very similar (and for the most part, the same) to normal Linq method usage. 

The _access_ the root of the parallel functionality,`ParallelQuery`, all that is required is the `AsParallel()` method to be called on an _IEnumerable_:

``` csharp
IEnumerable<int> array = Enumerable.Range(1, 1000);
ParallelQuery<int> parallelQuery = array.AsParallel();
```

With the ParallelQuery instance, traditional Linq methods can still available:

``` csharp
// output: 750,5
int average = parallelQuery
    .Where(i => i > 500)
    .Average(); 
```

However, there is now also _additional methods_ available, for example `ForAll` which will perform an _Action_ on each element, but in **parallel**:

``` csharp
var outputArray = new int[1000];
parallelQuery.ForAll(i =>
{
    outputArray[i - 1] = i * i;
});
```

Let's benchmark this to see how it performs against other parallel and not parallel operations which achieve the same outcome.

---

## Benchmark

In this set of benchmarks, we are operating on a _IEnumerable\<int\>_ with 100 items, and for each item in the source, the _PerformCalculation_ method will be called:

``` csharp
// the source items
IEnumerable<int> array = Enumerable.Range(1, 100);

// the method invoked
void PerformCalculation(int i)
{
    _ = i * i * i;
}
```

The following techniques were benchmarked:

- **List.ForEach:**

    ``` csharp
    public void ForEachList()
    {
        array.ToList()
           .ForEach(i => PerformCalculation(i));
    }
    ```

- **Foreach over an Array:**

    ``` csharp
    public void ForeachOverArray()
    {
        foreach (var i in array.ToArray())
        {
            PerformCalculation(i);
        }
    }
    ```

- **ParallelForEach:**

    ``` csharp
    public void ParallelForEach()
    {
        Parallel.ForEach(array, PerformCalculation);
    }
    ```     

- **ParallelQuery.ForAll:**

    ``` csharp
    public void ParallelQueryForAll()
    {
        array
        .AsParallel()
        .ForAll(i => PerformCalculation(i));
    }
    ```    

The results:

|              Method |         Mean |      Error |     StdDev | Ratio | RatioSD |  Gen 0 |  Gen 1 | Allocated |
|-------------------- |-------------:|-----------:|-----------:|------:|--------:|-------:|-------:|----------:|
|         ListForEach |    322.85 ns |   5.651 ns |   5.286 ns |  1.00 |    0.00 | 0.0825 |      - |     520 B |
|    ForeachOverArray |     91.40 ns |   1.770 ns |   1.656 ns |  0.28 |    0.01 | 0.0675 |      - |     424 B |
| ParallelQueryForAll | 13,481.85 ns | 172.827 ns | 161.663 ns | 41.77 |    0.86 | 2.0599 | 0.0610 |  12,585 B |
|     ParallelForEach |  7,978.07 ns |  41.364 ns |  34.540 ns | 24.70 |    0.43 | 4.6844 | 0.1068 |  24,175 B |
      

The `parallel versions are slow` - **VERY** slow compared to just iterating over the collection of items in sequence. 

Surely doing processing in parallel should make things process quicker overall? Generally yes - in this case however, the actual work being performed (the _PerformCalculation_ method) is done so quickly, that the `overhead of creating and managing the parallel tasks is a detriment to performance` vs just operating on the items in sequence.

However, what if the work being performed took slightly longer....

---

## Benchmark v2

We'll run the exact same benchmarks, with the same array size, but now the _PerformCalculation_ method will `take 2ms longer`:

``` csharp
void PerformCalculation(int i)
{
    _ = i * i * i;
    // simulate a longer 
    // running process
    Thread.Sleep(2);
}
```

The results of round 2:

|              Method |        Mean |    Error |    StdDev | Ratio | Allocated |
|-------------------- |------------:|---------:|----------:|------:|----------:|
|         ListForEach | 1,536.90 ms | 2.679 ms |  2.506 ms |  1.00 |      1 KB |
|    ForeachOverArray | 1,534.54 ms | 2.702 ms |  2.528 ms |  1.00 |      1 KB |
| ParallelQueryForAll |   152.84 ms | 0.730 ms |  0.683 ms |  0.10 |     13 KB |
|     ParallelForEach |    71.86 ms | 7.165 ms | 20.788 ms |  0.07 |     99 KB |


The `parallel versions are now 10-20 times faster!`. The _Parallel.ForEach_ is `twice as fast` as the _ParallelEnumerable.ForAll_, but uses `7 times the amount of memory` (and both parallel techniques use vastly more memory in comparison to the basic loops)

---

## Notes

There are a number of different techniques to solve a use case such as this - each with its own pros and cons, which would need to be evaluated for each use case. It's important to know about each technique, so a thorough evaluation can be done. Results may vary based on collection size, and process time, but based on the above use case:
- `Low memory usage` is most important? - use a _foreach_ loop
- `Fast throughput` is most important? - use _Parallel.ForEach_
- `Good throughput with good memory` usage? - use _ParallelEnumerable.ForAll_

---

## References

[ParallelEnumerable Class](https://docs.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable?view=net-6.0)   

---

<?# DailyDrop ?>140: 17-08-2022<?#/ DailyDrop ?>
